<h3> Welcome to the <em>TryHackMe ...</em></h3>
<h1>Cyber Security 101 learning path > Cryptography ></h1>
<h2>Hashing Basics</h2>
<p>Learn about hashing functions and their uses in password verification and file integrity checking.</p><br>
<p>October 25, 2024<br></p><br>

<div style="display: flex; justify-content: center; align-items: center;">
    <img src="https://github.com/user-attachments/assets/d3f354cd-5591-4ba1-ba55-55439d6569f7" width="150px" height="150px"/>
</div>
<br>

![image](https://github.com/user-attachments/assets/2757e316-00df-4ca4-9373-c43406e77da9)


<p>Hey there, fellow lifelong learner! I´m <a href="https://www.linkedin.com/in/rosanafssantos/">Rosana</a>, and I’m genuinely excited to join you on this adventure.<br>
It´s key part of my <strong><em>172</em></strong>-day-streak.<br>
Let´s get started!!<br><br>
Access this TryHackMe Room clicking <a href="https://tryhackme.com/r/room/hashingbasics">Hashing Basics</a>.</p><br>

<h2>Task 1 - Introduction</h2>

![image](https://github.com/user-attachments/assets/144e9156-efb5-4259-b813-2c13caa3f9b9)

<p>Consider the scenario where you just downloaded a 6 GB file and want to know whether the copy you downloaded is identical to the original file, bit for bit. How would you do that? Or if a good Samaritan handed you this 6 GB file on a USB memory drive, how can you be sure it is identical to the file you want to download?<br>

The answer to both of the above questions lies in comparing the hash values of the two files; if two hash values are equal, you can say with very high certainty that the two files are identical. But what is a hash value?<br>

A <code>hash value</code> is a fixed-size string or characters that is computed by a hash function. A <code>hash function</code> takes an input of an arbitrary size and returns an output of fixed length, i.e., a hash value. We will cover various exciting and clever uses of hash functions and values in this room.<br>

Note about terminology: We favoured the terms hash function and hash value. However, we occasionally use the word <strong><em>hash</em></strong> as a verb to mean calculate the hash value; moreover, we occasionally use the word hash by itself as a noun to refer to the hash value.</p>

<h3>Room Prerequisites</h3>
<p>This room is the third of three introductory rooms about cryptography. Because we will reference the topics in the previous two rooms, it is recommended that you finish the last two rooms before attempting this one.</p>
<ul style="list-style-type:square">
    <li><a href="https://tryhackme.com/r/room/cryptographybasics">Cryptography Basics</a></li>
    <li><a href="https://tryhackme.com/r/room/publickeycrypto">Public Key Cryptography BasicsCryptography Basics</a></li>
    <li>Hashing Basics (this room)</li>
</ul>

<h3>Learning Objectives</h3>
<p>Upon the completion of this room, you will learn about:</p>
<ul style="list-style-type:square">
    <li>Hash functions and collisions</li>
    <li>The role of hashing in authentication systems</li>
    <li>Recognizing stored hash values</li>
    <li>Cracking hash values</li>
    <li>The use of hashing for integrity protection</li>
</ul>

<p>To follow along, first, let’s start the <code>Virtual Machine</code> by pressing the <code>Start Machine</code> button below.</p>

![image](https://github.com/user-attachments/assets/c4b45918-2a7f-4469-a346-ad1c8621b229)

<p>The machine will start in <code>Split-Screen</code> view. In case the VM is not visible, use the blue <code>Show Split View</code> button at the top of the page.<br>

You can also access the virtual machine using SSH at the IP address <code>1MACHINE_IP</code> using the following credentials:</p>
<ul style="list-style-type:square">
    <li>Username: <code>user</code></li>
    <li>Password: <code>Tryhackme123!</code></li>
</ul>

<pre><code>$ ssh user@[REDACTED]
The authenticity of host '[REDACTED] ([REDACTED])' can't be established.
ECDSA key fingerprint is SHA256:[REDACTED].
Are you sure you want to continue connecting (yes/no)? yes
Warning: Permanently added '10.10.25.234' (ECDSA) to the list of known hosts.
user@[REDACTED]'s password: 
Welcome to Ubuntu 24.04.1 LTS (GNU/Linux 6.8.0-1016-aws x86_64)

 * Documentation:  https://help.ubuntu.com
 * Management:     https://landscape.canonical.com
 * Support:        https://ubuntu.com/pro

 System information as of Fri Oct 25 21:45:03 UTC 2024

  System load:  0.08               Temperature:           -273.1 C
  Usage of /:   29.6% of 14.47GB   Processes:             102
  Memory usage: 11%                Users logged in:       0
  Swap usage:   0%                 IPv4 address for ens5: [REDACTED]

 * Ubuntu Pro delivers the most comprehensive open source security and
   compliance features.

   https://ubuntu.com/aws/pro

Expanded Security Maintenance for Applications is not enabled.

0 updates can be applied immediately.

Enable ESM Apps to receive additional future security updates.
See https://ubuntu.com/esm or run: sudo pro status


The list of available updates is more than a week old.
To check for new updates run: sudo apt update

Last login: Fri Oct 25 21:23:47 2024 from [REDACTED]
user@[REDACTED]:~$ 
</code></pre>

> 1.1 - <em>Let´s begin!</em><br>
>> <strong>No answer needed</strong><br>
<p><br></p>

<h2>Task 2 - Hash Functions</h2>
<h3>What is a Hash Function?</h3>
<p>Hash functions are different from encryption. There is no key, and it’s meant to be impossible (or computationally impractical) to go from the output back to the input.<br>

A hash function takes some input data of any size and creates a summary or digest of that data. The output has a fixed size. It’s hard to predict the output for any input and vice versa. Good hashing algorithms will be relatively fast to compute and prohibitively slow to reverse, i.e., go from the output and determine the input. Any slight change in the input data, even a single bit, should cause a significant change in the output.<br>

Let’s check an example. In the terminal below, we can see two files; the first contains the letter T, while the second contains the letter U. If you check T and U in an ASCII table or using <code>hexdump</code>, you will notice that the two letters differ by a single bit.</p>

<ul style="list-style-type:square">
    <li>The letter T is <code>54</code> in hexadecimal, i.e., <code>01010100</code> in binary.</li>
    <li>The letter U is <code>55</code> in hexadecimal, i.e., <code>01010101</code> in binary.</li>
</ul>

<p>Consequently, the following two files differ by a single bit. However, if we compare their MD5 (Message-Digest Algorithm 5) hashes, their SHA1 (Secure Hash Algorithm 1) hashes, or their SHA-256 (Secure Hash Algorithm 256) hashes, we will notice that they are entirely different. We recommend that you try the commands below yourself. The files are located in <code>~/Hashing-Basics/Task-2/</code>.</p>

![image](https://github.com/user-attachments/assets/2d3b82e2-662a-4082-8cd8-8aa184bdcee7)

<p>The output of a hash function is typically raw bytes, which are then encoded. Common encodings are base64 or hexadecimal. <code>md5sum</code>, <code>sha1sum</code>, <code>sha256sum</code>, and <code>sha512sum</code> produce their outputs in hexadecimal format. Remember that hexadecimal format prints each raw byte as two hexadecimal digits.</p>

<h3>Why is Hashing Important?</h3>
<p>Hashing plays a vital role in our daily use of the Internet. Like other cryptographic functions, hashing remains hidden from the user. Hashing helps protect data’s integrity and ensure password confidentiality.<br>

Consider this example of hashing being used to protect your cyber security. When you log into TryHackMe, the server uses hashing to verify your password. In fact, as per good security practices, a server does not record your password; it records the hash value of your password. Whenever you want to log in, it will calculate the hash value of the password you submitted with the recorded hash value. Similarly, when you log into your computer, hashing plays a role in verifying your password. You interact more indirectly with hashing than you would think, and almost daily in the context of passwords.</p>

<h3>What´s a hash Collision?</h3>
<p>A hash collision is when two different inputs give the same output. Hash functions are designed to avoid collisions as best as possible. Furthermore, hash functions are designed to prevent an attacker from being able to create, i.e., engineer, a collision intentionally. However, because the number of inputs is practically unlimited and the number of possible outputs is limited, this leads to a pigeonhole effect.<br>

As a numeric example, if a hash function produces a 4-bit hash value, we only have 16 different hash values. The total number of possible hash values is <code>2number_of_bits = 24 = 16</code>. The probability of a collision is relatively very high.<br>

The <code>pigeonhole effect</code> states that the number of items (pigeons) is more than the number of containers (pigeonholes); some containers must hold more than one item. In other words, in this context, there are a fixed number of different output values for the hash function, but you can give it any size input. As there are more inputs than outputs, some inputs must inevitably give the same output. If you have 21 pigeons and 16 pigeonholes, some of the pigeons are going to share the pigeonholes. Consequently, collisions are unavoidable. However, a good hash function ensures that the probability of a collision is negligible.<br>

MD5 and SHA1 have been attacked and are now considered insecure due to the ability to engineer hash collisions. However, no attack has yet given a collision in both algorithms simultaneously, so if you compare the MD5 and SHA1 hash, you will see that they’re different. You can view the MD5 collision example on the <a href="https://www.mscs.dal.ca/~selinger/md5collision/">MD5 Collision Demo</a> page; furthermore, you can read the details of the SHA1 collision attack at <a href="https://shattered.io/">Shattered</a>. Due to these, you shouldn’t trust either algorithm for hashing passwords or data.</p><br>

> 2.1 - What is the SHA256 hash of the <code>passport.jpg</code> file in <code>~/Hashing-Basics/Task-2</code>?</em><br>
>> <strong>77148c6f605a8df855f2b764bcc3be749d7db814f5f79134d2aa539a64b61f02</strong><br>
<p></p>

<pre><code>$ user@[REDACTED]:~$ cd ~/Hashing-Basics/Task-2
user@[REDACTED]:~/Hashing-Basics/Task-2$ ls
file1.txt  file2.txt  passport.jpg
user@i[REDACTED]:~/Hashing-Basics/Task-2$ sha256sum passport.jpg
77148c6f605a8df855f2b764bcc3be749d7db814f5f79134d2aa539a64b61f02  passport.jpg
user@[REDACTED]:~/Hashing-Basics/Task-2$ 
</code></pre><br>

> 2.2 - What is the output size in bytes of the MD5 hash function?</em><br>
>> <strong>16</strong><br>
<p><br></p>

> 2.3 - If you have an 8-bit hash output, how many possible hash values are there?</em><br>
>> <strong>256</strong><br>
<p><br></p>

<h2>Task 3 - Insecure Password Storage for Authentication</h2>
<p>Hashing has many uses in Cyber Security. In this room, we will focus on two uses: password storage and data integrity. We refer to password storage when used for authentication.<br>

It is important to note that <strong>this does not apply to password managers, where you must retrieve your password in cleartext. On the other hand, authentication mechanisms only need to confirm that the user knows the password</strong> so they can be granted access to the resource; therefore, this problem differs from password managers.</p>

<h3>Stories of Insecure Password Storage for Authentication</h3>
<p>Most web applications need to verify a user’s password at some point. Storing these passwords in plaintext is a very insecure security practice. You’ve probably seen news stories about companies that have had their database leaked. Knowing that many people use the same password on their various accounts, including their online banking, leaking the password from one account jeopardises the security of all other accounts.<br>

We will visit three insecure practices when it comes to passwords:</p>
<ul style="list-style-type:square">
    <li>Storing passwords in plaintext</li>
    <li>Storing passwords using an insecure hashing algorithm</li>  
  <li>Storing passwords using an insecure hashing algorithm</li>
</ul>

<h4>Storing Passwords in Plaintext</h4>
<p>Quite a few data breaches have leaked plaintext passwords. You’re probably familiar with the “rockyou.txt” password list on Kali Linux, among many other offensive security distributions. This password list came from RockYou, a company that developed social media applications and widgets. They stored their passwords in plaintext, and the company had a data breach. The text file contains over 14 million passwords. You can find <code>rockyou.txt</code> in the <code>/usr/share/wordlists</code> directory.</p>

![image](https://github.com/user-attachments/assets/607b54e7-6d6a-482b-8b8c-b35c11e81b6b)

<h4>Using an Insecure Encryption Algorithm</h4>
<p>Adobe’s notable data breach was slightly different. Instead of using a secure hashing function to store the hash values of the passwords, the company used a deprecated encryption format. Furthermore, password hints were stored in plain text, sometimes containing the password itself. Consequently, the plaintext password could be retrieved relatively quickly.</p>

<h4>Using an Insecure Hash Function</h4>
<p>LinkedIn also suffered a data breach in 2012. LinkedIn used an insecure hashing algorithm, the SHA-1, to store user passwords. Furthermore, no <code>password salting</code> was used. Password salting refers to adding a <code>salt</code>, i.e., a random value, to the password before it is hashed.</p>

> 3.1 - What is the 20th password in <code>rockyou.txt</code>?</em><br>
>> <strong>qwerty</strong><br>
<p><br></p>

<pre><code>$ user@[REDACTED]:~$ locate rockyou.txt
/usr/share/wordlists/rockyou.txt
</code></pre>

<pre><code>$ user@[REDACTED]: head -n 20 /usr/share/wordlists/rockyou.txt
123456
12345
123456789
password
iloveyou
princess
1234567
rockyou
12345678
abc123
nicole
daniel
babygirl
monkey
lovely
jessica
654321
michael
ashley
qwerty
</code></pre>

<h2>Task 4 - Using Hashing fpr Secure Password Storage</h2>
<h3>Using Hashing to Store Passwords</h3>
<p>This is where hashing comes in. What if, instead of storing the password, you just stored its hash value using a secure hashing function? This process means you never have to store the user’s password, and if your database is leaked, an attacker will have to crack each password to find out what the password was.<br>

There’s just one problem with this. What if two users have the same password? As a hash function will always turn the same input into the same output, you will store the same password hash for each user. That means if someone cracks that hash, they gain access to more than one account. It also means someone can create a Rainbow Table to break the hashes.<br>

A <code>Rainbow Table</code> is a lookup table of hashes to plaintexts, so you can quickly find out what password a user had just from the hash. A rainbow table trades the time to crack a hash for hard disk space, but it takes time to create. Here’s a quick example to get an idea of what a rainbow table looks like.</p>

![image](https://github.com/user-attachments/assets/85cf65ec-2a54-45a6-aeec-7820839e84ff)

<p>Websites like <a href="https://crackstation.net/">Crackstation</a> and <a href="https://hashes.com/en/decrypt/hash">Hashes.com</a> internally use massive rainbow tables to provide fast password cracking for <code></code>hashes without salts</code>. Doing a lookup in a sorted list of hashes is quicker than trying to crack the hash.</p>

![image](https://github.com/user-attachments/assets/e0a4ba4a-a7fd-4790-abb1-3e5158d9e7b9)

<h3>Protecting Against Rainbow Tables</h3>
<p>To protect against rainbow tables, we add a salt to the passwords. The salt is a randomly generated value stored in the database and should be unique to each user. In theory, you could use the same salt for all users, but duplicate passwords would still have the same hash and a rainbow table could still be created for passwords with that salt.<br>

The salt is added to either the start or the end of the password before it’s hashed, and this means that every user will have a different password hash even if they have the same password. Hash functions like Bcrypt and Scrypt handle this automatically. Salts don’t need to be kept private.</p>

<h3>Example of Securely Storing Passwords</h3>
<p>You can find many good guides online that promote best security practices when storing passwords. Please check if there are any standards you need to follow when storing passwords before adopting one. Consider this example following good security practices when storing user passwords:</p>


<h3>Example of Securely Storing Passwords</h3>
<p>Considering the problem of saving passwords for authentication, why don’t we encrypt passwords instead of all these cumbersome steps? The reason is that even if we select a secure hashing algorithm to encrypt the passwords before storing them, we still need to store the used key. Consequently, if someone gets the key, they can easily decrypt all the passwords.</p>

> 4.1 - Manually check the hash “4c5923b6a6fac7b7355f53bfe2b8f8c1” using the rainbow table above.</em><br>
>> <strong>inS3CyourP4$$</strong><br>
<p><br></p>

![image](https://github.com/user-attachments/assets/6c21ba62-ec03-4794-9aaf-74b8f22ad830)

> 4.2 - Crack the hash “5b31f93c09ad1d065c0491b764d04933” using an online tool.</em><br>
>> <strong>tryhackme</strong><br>
<p><br></p>

![image](https://github.com/user-attachments/assets/50f20934-42f6-486f-9b3f-6a30607d6b95)

> 4.3 - Should you encrypt passwords in password-verification systems? Yea/Nay.</em><br>
>> <strong>Nay</strong><br>
<p><br></p>

<h2>Task 5 - Recognising Password Hashes</h2>

<p>From the cyber defensive security perspective, we covered how to store passwords securely for authentication systems. Let’s tackle this from the offensive security perspective; if we start with a hash, how can we recognise its type, eventually crack it, and recover the original password?

Automated hash recognition tools such as <a href="https://pypi.org/project/hashID/">hashID</a> exist but are unreliable for many formats. For hashes that have a prefix, the tools are reliable. Use a healthy combination of context and tools.  If you find the hash in a web application database, it’s more likely to be MD5 than NTLM (NT LAN Manager). Automated hash recognition tools often get these hash types mixed up, highlighting the importance of learning yourself.</p>

<h3>Linux Passwords</h3>
<p>On Linux, password hashes are stored in <code>/etc/shadow</code>, which is normally only readable by root. They used to be stored in <code>/etc/passwd</code>, which was readable by everyone.<br>

The <code>shadow</code> file contains the password information. Each line contains nine fields, separated by colons (<code>:</code>). The first two fields are the login name and the encrypted password. More information about the other fields can be found by executing <code>man 5 shadow</code> on a Linux system.<br>

The encrypted password field contains the hashed passphrase with four components: prefix (algorithm id), options (parameters), salt, and hash. It is saved in the format <code>$prefix$options$salt$hash</code>. The prefix makes it easy to recognise Unix and Linux-style passwords; it specifies the hashing algorithm used to generate the hash.<br>

Here’s a quick table of some of the most common Unix-style password prefixes you might encounter. They are listed in the order of decreasing strength. You can read more about them by checking the man page with <code>man 5 crypt</code>.</p>

![image](https://github.com/user-attachments/assets/422b3819-7856-457d-a6e2-5967f6359401)

<h3>Modern Linux Example</h3>
<p>Consider the following line from a modern Linux system’s <code>shadow</code> password file.</p>

![image](https://github.com/user-attachments/assets/14596425-ea16-415b-9fad-be8db9e3f610)

<p>The fields are separated by colons. The important ones are the username and the hash algorithm, salt, and hash value. The second field has the format <code>$prefix$options$salt$hash</code>.<br>

In the example above, we have four parts separated by <code>$</code>:</p>
<ul style="list-style-type:square">
    <li><code>y</code> indicates the hash algorithm used, <code>yescrypt</code></li>
    <li><code>j9T</code> is a parameter passed to the algorithm</li>  
    <li><code>76UzfgEM5PnymhQ7TlJey1</code> is the salt used</li>
    <li><code>/OOSg64dhfF.TigVPdzqiFang6uZA4QA1pzzegKdVm4</code>code> is the hash value</li>
</ul>

<h3>MS Windows Passwords</h3>
<p>MS Windows passwords are hashed using NTLM, a variant of MD4. They’re visually identical to MD4 and MD5 hashes, so it’s very important to use context to determine the hash type.<br>

On MS Windows, password hashes are stored in the SAM (Security Accounts Manager). MS Windows tries to prevent normal users from dumping them, but tools like mimikatz exist to circumvent MS Windows security. Notably, the hashes found there are split into NT hashes and LM hashes.<br>

A great place to find more hash formats and password prefixes is the <a href="https://hashcat.net/wiki/doku.php?id=example_hashes">Hashcat Example Hashes</a> page. For other hash types, you’ll typically need to check the length or encoding or even conduct some research into the application that generated them. Never underestimate the power of research.</p>

> 5.1 - What is the hash size in yescrypt?</em><br>
>> <strong>256</strong><br>
<p><br></p>

> 5.2 - What’s the Hash-Mode listed for Cisco-ASA MD5?</em><br>
>> <strong>2410</strong><br>
<p><br></p>

> 5.3 - What hashing algorithm is used in Cisco-IOS if it starts with $9$?</em><br>
>> <strong>scrypt</strong><br>
<p><br></p>

<h2>Task 6 - Password Cracking</h2>

<p>We’ve already mentioned rainbow tables as a method to crack hashes that don’t use a salt, but what if there’s a salt involved?<br>

You can’t “decrypt” password hashes. They’re not encrypted. You have to crack the hashes by hashing many different inputs (such as <code>rockyou.txt</code> as it covers many possible passwords), potentially adding the salt if there is one and comparing it to the target hash. Once it matches, you know what the password was. Tools like <a href="https://hashcat.net/hashcat/">Hashcat</a> and <a href="https://www.openwall.com/john/">John the Ripper</a> are commonly used for these purposes.</p>

<h3>Cracking Passwords with GPUs</h3>
<p>Modern GPUs (Graphics Processing Units) have thousands of cores. They are specialised in digital image processing and accelerating computer graphics. Although they can’t do the same sort of work that a CPU can, they are very good at some mathematical calculations involved in hash functions. You can use a graphics card to crack many hash types quickly. Some hashing algorithms, such as Bcrypt, are designed so that hashing on a GPU does not provide any speed improvement over using a CPU; this helps them resist cracking.

Cracking on VMs?</p>
<p>It’s worth mentioning that VMs (Virtual Machines) normally don’t have access to the host’s graphics card(s). Depending on the virtualisation software you are using, you can set this up, but it is cumbersome. Furthermore, performance degradation occurs as you use the CPU from a virtualised OS, and when your purpose is to crack a hash, you need every extra CPU cycle.<br>

If you want to run <a href="https://hashcat.net/hashcat/">Hashcat</a>, it’s best to run it on your host to make the most of your GPU, if available. If you prefer MS Windows, you are in luck; MS Windows builds are available on the website, and you can run it from PowerShell. You can get Hashcat working with OpenCL in a VM, but the speeds will likely be worse than cracking on your host.<br>

<a href="https://www.openwall.com/john/">John the Ripper</a> uses CPU by default and works in a VM out of the box, although you may get better speeds running it on the host OS to avoid any virtualisation overhead and make the most of your CPU cores and threads.</p>

<h3>Time to Crack Some Hashes</h3>
<p></p>I’ll provide the hashes. Crack them. You can choose how. You’ll need to use online tools, <a href="https://hashcat.net/hashcat/">Hashcat</a>, or <a href="https://www.openwall.com/john/">John the Ripper</a>. Although you can use <a href="https://hashes.com/en/decrypt/hash">online rainbow tables</a> to solve the following, we strongly advise against doing that as this will restrict your learning experience. For the first three questions, using <code>hashcat</code> along with <code>rockyou.txt</code> is enough to find the answers.<br>

Hashcat uses the following basic syntax: <code>hashcat -m <hash_type> -a <attack_mode> hashfile wordlist</code>, where:</p>
<ul style="list-style-type:square">
    <li><code>-m <hash_type></code> specifies the hash-type in numeric format. For example, <code>-m 1000</code> is for NTLM. Check the official documentation (<code>man hashcat</code>) and example page to find the hash type code to use.</code></li>
    <li><code>-a <attack_mode></code> specifies the attack-mode. For example, <code>-a 0</code> is for straight, i.e., trying one password from the wordlist after the other.</li>  
    <li><code>hashfile</code> is the file containing the hash you want to crack.</li>
    <li><code>wordlist</code> is the security word list you want to use in your attack.</li>
</ul>

<p>For example, <code>hashcat -m 3200 -a 0 hash.txt /usr/share/wordlists/rockyou.txt</code> will treat the hash as Bcrypt and try the passwords in the <code>rockyou.txt</code> file.</p><br>

> 6.1 - Use <code>hashcat</code> to crack the hash, <code>$2a$06$7yoU3Ng8dHTXphAg913cyO6Bjs3K5lBnwq5FJyA6d01pMSrddr1ZG</code>, saved in <code>~/Hashing-Basics/Task-6/hash1.txt</code>.</em><br>
>> <strong>85208520</strong><br>
<p><br></p>

<pre><code>$ user@[REDACTED:~/Hashing-Basics/Task-6$ ls
hash1.txt  hash2.txt  hash3.txt  hash4.txt
</code></pre><br>

<pre><code>$ hashid -m hash1.txt                       
--File 'hash1.txt'--
Analyzing '$2a$06$7yoU3Ng8dHTXphAg913cyO6Bjs3K5lBnwq5FJyA6d01pMSrddr1ZG'
[+] Blowfish(OpenBSD) [Hashcat Mode: 3200]
[+] Woltlab Burning Board 4.x 
[+] bcrypt [Hashcat Mode: 3200]
</code></pre><br>

<pre><code>$ hashcat -m 3200 -a 0 hash1.txt rockyou.txt
</code></pre><br>

> 6.2 - Use <code>hashcat</code> to crack the SHA2-256 hash, <code>9eb7ee7f551d2f0ac684981bd1f1e2fa4a37590199636753efe614d4db30e8e1</code>, saved in saved in <code>~/Hashing-Basics/Task-6/hash2.txt</code>.</em><br>
>> <strong>halloween</strong><br>
<p>spaceman<br></p>

<pre><code>$ hashid -m hash2.txt                       
--File 'hash2.txt'--
Analyzing '9eb7ee7f551d2f0ac684981bd1f1e2fa4a37590199636753efe614d4db30e8e1'
[+] Snefru-256 
[+] SHA-256 [Hashcat Mode: 1400]
[+] RIPEMD-256 
[+] Haval-256 
[+] GOST R 34.11-94 [Hashcat Mode: 6900]
[+] GOST CryptoPro S-Box 
[+] SHA3-256 [Hashcat Mode: 5000]
[+] Skein-256 
[+] Skein-512(256) 
</code></pre><br>

<pre><code>$ hashcat -m 1400 -a 0 hash2.txt rockyou.txt
</code></pre><br>

> 6.3 - Use <code>hashcat</code> to crack the hash, <code>$6$GQXVvW4EuM$ehD6jWiMsfNorxy5SINsgdlxmAEl3.yif0/c3NqzGLa0P.S7KRDYjycw5bnYkF5ZtB8wQy8KnskuWQS3Yr1wQ0</code>, saved in <code>~/Hashing-Basics/Task-6/hash3.txt</code>.</em><br>
>> <strong>spaceman</strong><br>
<p><br></p>

<pre><code>$ hashid -m hash3.txt
--File 'hash3.txt'--
Analyzing '$6$GQXVvW4EuM$ehD6jWiMsfNorxy5SINsgdlxmAEl3.yif0/c3NqzGLa0P.S7KRDYjycw5bnYkF5ZtB8wQy8KnskuWQS3Yr1wQ0'
[+] SHA-512 Crypt [Hashcat Mode: 1800]
</code></pre><br>

<pre><code>$ hashcat -m 1800 -a 0 hash3.txt rockyou.txt
</code></pre><br>

> 6.4 - Crack the <code>hash</code>, <code>b6b0d451bbf6fed658659a9e7e5598fe</code>, saved in <code>~/Hashing-Basics/Task-6/hash4.txt</code>.</em><br>
>> <strong>funforyou</strong><br>
<p><br></p>

![image](https://github.com/user-attachments/assets/81b0b4f8-186b-4160-8560-1741c13e006c)


<h2>Task 7 - Hashing for Integrity Checking</h2>

> 7.1 - What is SHA256 hash of <code>libgcrypt-1.11.0.tar.bz2</code> found in <code>~/Hashing-Basics/Task-7</code>?</em><br>
>> <strong>09120c9867ce7f2081d6aaa1775386b98c2f2f246135761aae47d81f58685b9c</strong><br>
<p><br></p>

<pre><code>$ user@[REDACTED]:~/Hashing-Basics/Task-7$ sha256sum libgcrypt-1.11.0.tar.bz2
09120c9867ce7f2081d6aaa1775386b98c2f2f246135761aae47d81f58685b9c  libgcrypt-1.11.0.tar.bz2
</code></pre><br>

> 7.2 - What’s the hashcat mode number for <code>HMAC-SHA512 (key = $pass)</code>?</em><br>
>> <strong>1750</strong><br>
<p><br></p>

![image](https://github.com/user-attachments/assets/a52989a0-5959-44a2-ba18-a6c78c351fe4)


<h2>Task 8 - Conclusion</h2>

> 8.1 - Use base64 to decode <code>RU5jb2RlREVjb2RlCg==</code>, saved as <code>decode-this.txt</code> in <code>~/Hashing-Basics/Task-8</code>. What is the original word?</em><br>
>> <strong>ENcodeDEcode</strong><br>
<p><br></p>

<pre><code>$ user@[REDACTED]:~/Hashing-Basics/Task-8$ cat decode-this.txt | base64 -d 
ENcodeDEcode
</code></pre><br>

> 8.2 - Ensure you have noted the various concepts and tools explored in this room.</em><br>
>> <strong>No answer needed</strong><br>
<p><br></p>

<h2>Room Complete</h2>
<p>Keep learning, keep growing!<br>

![image](https://github.com/user-attachments/assets/cca5a173-50ed-4960-8425-b7c62831c9b3)

<h2>My journey</h2>
<p></p>Following I share the status of my journey in TryHackMe.</p>

![image](https://github.com/user-attachments/assets/5e24cf7c-74e8-433b-b7b7-0fba269730ba)

<p></p>

<p style="text-align: center;">Thank you for coming. Hope to learn together again!!</p>
